---
layout: post
title:  "3.4 인덱스 설계"
date:   2019-09-17
categories: SQL튜닝
---  
## 3.4.1 인덱스 설계가 어려운 이유
---  
*인덱스가 많으면 생기는 문제*  

> DML 성능 저하 (TPS 저하)  
> 데이터베이스 사이즈 증가 (디스크 공간 낭비)  
> 데이터베이스 관리 및 운영 비용 상승  

<br>
핵심 트랜잭션이 참조하는 테이블에 대한 DML 성능 저하는 TPS 저하로 이어진다.  
꼭 필요하지 않은 인덱스를 많이 만들면 디스크 공간을 낭비하고,  
데이터베이스 사이즈가 커지는 만큼 백업, 복제, 재구성 등을 위한 운영 비용도 상승한다.  
개별 쿼리 성능 뿐만 아니라 그 개수를 최소화함으로써 DML 부하를 줄여야 하므로 인덱스 설계가 어렵다.  
  
인덱스 추가는 시스템에 부하를 주고, 인덱스 변경은 운영 리스크가 크다..  
---  
## 3.4.2 가장 중요한 두 가지 선택 기준
--- 
인덱스 스캔 방식에 여러가지가 있지만 가장 정상적이고 일반적인 방식은 Index Rage Scan.  
이를 위해서는 인덱스 선두 컬럼을 조건절에 반드시 사용해야 한다.  
따라서 결합 인덱스를 구성할 때 두가지 조건을 공식처럼 외워야 한다.  
*인덱스 스캔 효율성 판단 기준*  
1. 조건절에 항상 사용하거나, 자주 사용하는 컬럼을 선정한다.  
2. '=' 조건으로 자주 조회하는 컬럼을 앞쪽에 둔다.  
<br>
---  
## 3.4.3 스캔 효율성 이외의 판단 기준
---  
스캔 효율성 이외의 가장 중요한 하나를 꼽자면 수행빈도다.  
자주 수행하지 않는 SQL이면 인덱스 스캔 과정에 약간의 비효율이 있어도 큰 문제가 아닐 수 있다.  
반면, 수행빈도가 매우 높은 SQL에는 앞서 설명한 공식을 이용해 최적의 인덱스를 구성해줘야 한다.  
자세한 예제는 책 참고..
<br>
데이터량도 인덱스를 설계할 때 중요한 판단 기준이다.  
데이터량이 적다면 굳이 인덱스를 많이 만들 필요가 없다. Full Scan으로도 충분히 빠르기 때문이다.  
---  
## 3.4.4 공식을 초월한 전략적 설계
---  
SQL 튜닝 전문가라면, 열개 중 최적을 달성해야 할 가장 핵심적인 액세스 경로 한두 개를 전략적으로 선택해서 최적 인덱스를 설계하고, 나머지 액세스 경로는 약간의 비효율이 있더라도 목표 성능을 만족하는 수준으로 인덱스를 구성할 수 있어야 한다.  
예제는 책 참고..  
인덱스 개수를 최소화 하면, 사용빈도가 높거나 중요한 액세스 경로가 새로 도출됐을 때 최적의 인덱스를 추가할 여유도 생긴다.
---  
## 3.4.5 소트 연산을 생략하기 위한 컬럼 추가
---  
인덱스는 항상 정렬 상태를 유지하므로 ORDER BY, GROUP BY를 위한 소트 연산을 생략할 수 있게 해준다.  
따라서 조건절에 사용하지 않는 컬럼이라도 소트 연산을 생략할 목적으로 인덱스 구성에 포함시킴으로써 성능 개선을 도모할 수 있다.  
*'='이 아닌 조건절 컬럼들은 반드시 ORDER BY 컬럼보다 뒤쪽에 두어야 소트 연산을 생략할 수 있다.*  
<br>
*I/O를 최소화하면서도 소트 연산을 생략하려면, 아래 공식에 따라 인덱스를 구성하면 된다.*
> '=' 연산자로 사용한 조건절 컬럼 선정  
> ORDER BY 절에 기술한 컬럼 추가  
> '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정  
<br>
*IN 조건은 '='이 아니다.*  
소트 연산을 생략하려면 IN 조건절이 IN-List Iterator 방식으로 풀려선 안된다. 즉, IN 조건절을 인덱스 액세스 조건으로 사용하면 안된다. 필터 조건으로 사용해야 한다.  
---  
## 3.4.6 결합 인덱스 선택도
---  
인덱스 생성 여부를 결정할 때는 선택도가 충분히 낮은지가 중요한 판단 기준.  
'선택도(Selectivity)'란 전체 레코드 중에서 조건절에 의해 선택되는 레코드 비율을 말하며, 선택도에 총 레코드 수를 곱해서 '카디널리티'를 구한다. '인덱스 선택도'는 인덱스 컬럼을 모두 '='로 조회할 때 평균적으로 선택되는 비율을 의미힌다.  
선택도가 높은(카디널리티가 높은) 인덱스는 생성해봐야 효용가치가 별로 없다. 테이블 액세스가 많이 발생하기 때문이다. 따라서 인덱스를 생성할 때는 반드시 선택도/카디널리티를 확인해야한다.  
예제는 책 참고..  
<br>
결론적으로, 인덱스 생성 여부를 결정할 때는 선택도가 매우 중요하지만, 컬럼 간 순서를 결정할 때는 각 컬럼의 선택도 보다 필수 조건 여부, 연산자 형태가 더 중요한 판단기준임.  
어느 컬럼을 앞에 두는 것이 유리한지는 상황에 따라 판단할 일.  
---  
## 3.4.7 중복 인덱스 제거
---  
예제 책 참고.. 
---  
## 3.4.8 인덱스 설계도 작성
---  
예제 책 참고..
인덱스 설계전에 파티션 설계를 먼저 진행하거나 최소한 병행해야 제대로 된 인덱스 전략을 수립할 수 있음..  
<br>
<br>
<br>
<br>
<br>
<br>
![img01]({{ site.baseurl }}/images/post/sqlTuning/book/bookCover.PNG)<br>
<br>
본 포스팅은 친절한 SQL 튜닝 온라인 스터디를 진행하면서 공부한 내용을 바탕으로 작성하였습니다.<br>
<br>
<br>
<br>