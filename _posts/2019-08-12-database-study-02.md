---
layout: post
title:  "1.2 SQL 공유 및 재사용"
date:   2019-08-12
categories: Database
---  
## 1.2.1 소프트 파싱 vs 하드 파싱
---
SQL파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해두는 메모리 공간을 '**라이브러리 캐시(Library Cache)**'라고 한다.  
  

사용자가 SQL문을 전달하면 DBMS는 SQL을 파싱한 후 해당 SQL이 라이브러리 캐시에 존재하는지부터 확인한다.  
캐시에서 찾으면 곧바로 실행단계로 넘어가지만, 찾지못하면 최적화 단계를 거친다. 
  

**소프트 파싱(Soft Parsing)** : SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것
  
**하드 파싱(Hard Parsing)** : SQL을 캐시에서 찾는데 실패하여 최적화 및 로우 소스 생성 단계까지 모두 거치는 것
  
  
하드파싱은 CPU를 많이 소비하는 몇 안 되는 작업 중 하나다.  
내부 프로시저를 한번만 사용하고 버린다면 굉장히 비효율적이기 때문에 **라이브러리 캐시**가 필요하다.  
  
<br>
<br>
<br>
<br>
<br>

## 1.2.2 바인드 변수의 중요성
---
**이름없는 SQL의 문제점**
> SQL은 이름이 따로 없으며 전체 텍스트가 이름 역할을 한다.
> 딕셔너리에 저장하지도 않고, 캐시공간이 부족하면 버려졌다가 다음에 다시 실행할 때 똑같은 최적화 과정을 거쳐 캐시에 저장된다.
> 처음 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다. 
  
<br>
  
**대부분의 DBMS가 SQL을 사용자 정의 함수/프로시저처럼 영구 저장하지 않는 이유?**
> SQL은 이름이 따로 없고, SQL 자체가 이름이기 때문에 텍스트 중 작은 부분이라도 수정되면 그 순간 다른 객체가 새로 탄생하는 구조다.
> 오라클 10g에서 등장한 SQL ID를 이름으로 사용해도 마찬가지다. SQL 텍스트가 변하면 SQL ID도 변한다.
> 일회성 또는 무효화된 SQL까지 모두 저장하려면 많은 공간이 필요하고, SQL 속도도 느려진다.
  
<br>
  
쇼핑몰에서 고객들을 대상으로 20% 이벤트 당첨자를 추출하는 SQL 작성한다면  
고객ID만 달라지고 프로시저의 내부처리 루틴이 모두 같기 때문에,  
프로시저를 여러개 생성할것이 아니라 로그인 ID를 파라미터로 받는 프로시저 하나를 공유하면서 재사용 하는것이 마땅하다.

```sql
create procedure LOGIN (login_id in varchar2) { ... }
```     

이처럼 파라미터 Driven 방식으로 SQL을 작성하는 방법이 제공되는데, 바인드 변수가 바로 login_id 다.  
바인드 변수를 사용하면 하드파싱은 최초 한번만 일어나고, 캐싱된 SQL이 재사용된다. 
  

<br>
<br>
<br>
<br>
<br>
![img01]({{ site.baseurl }}/images/post/sqlTuning/book/bookCover.PNG)<br>
<br>
본 포스팅은 친절한 SQL 튜닝 온라인 스터디를 진행하면서 공부한 내용을 바탕으로 작성하였습니다.<br>
<br>
<br>
<br>
<br>