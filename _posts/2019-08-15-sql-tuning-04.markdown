---
layout: post
title:  "2.1 인덱스 구조 및 탐색"
date:   2019-08-15
categories: SQL튜닝
---  
## 2.1.1 미리보는 인덱스 튜닝
---
**데이터를 찾는 두 가지 방법**  
1) 테이블 전체를 스캔한다.  
2) 인덱스를 이용한다.  

<br>

**인덱스 튜닝의 두 가지 핵심요소**  
1) 인덱스 스캔 효율화 튜닝 : 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것.  
2) 랜덤 액세스 최소화 튜닝 : 테이블 액세스 횟수를 줄이는 것. 인덱스 스캔 후 테이블 레코드를 액세스 할 때 랜덤 I/O 방식을 사용한다. 성능에 미치는 영향이 더 크다.  

<br>

**SQL 튜닝은 랜덤 I/O와의 전쟁**  
성능을 위해 DBMS가 제공하는 많은 기능이 느린 랜덤 I/O를 극복하기 위해 개발됐다. IOT, 클러스터, 파티션에서부터 테이블 Prefetch, Batch I/O처럼 겉으로는 잘 드러나지 않는 숨은 기능까지 모두가 그렇다.  

<br>
<br>

## 2.1.2 인덱스 구조
---
인덱스를 이용하면 일부만 읽고 멈출 수 있는 범위 스캔(Range Scan)이 가능하다.  
범위스캔이 가능한 이유는 인덱스가 정렬되어 있기 때문이다.  
DBMS는 일반적으로 B*Tree 인덱스를 사용한다.

루트와 브랜치 블록에 있는 각 레코드는 하위 블록에 대한 주소값을 갖는다.  
키값은 하위 블록에 저장된 키값의 범위를 나타낸다.  
리프블록에 저장된 각 레코드는 키값 순으로 정렬되어있을 뿐만 아니라 테이블 레코드가 가리키는 주소값, 즉 ROW ID를 갖는다. 

> ROWID = 데이터 블록 주소 + 로우 번호  
> 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호  
> 블록번호 : 데이터파일 내에서 부여한 상대적 순번  
> 로우번호 : 블록 내 순번  

<br>
**인덱스 탐색 과정**
> 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정.  
> 수평적 탐색 : 데이터를 찾는 과정  

<br>
<br>

## 2.1.3 인덱스 수직적 탐색
---
인덱스 스캔 시작지점을 찾는 과정. 
수직적 탐색은 '조건을 만족하는 레코드'를 찾는 과정이 아니라 '조건을 만족하는 첫 번째 레코드'를 찾는 과정이다.

<br>
<br>

## 2.1.4 인덱스 수평적 탐색 
---
인덱스 리프 블록을 수평적으로 스캔하며 본격적으로 데이터를 찾는 과정이다.  
인덱스 리프 블록끼리는 양방향 연결 리스트(double linked list) 구조로 서로 앞뒤 블록에 대한 주소값을 갖는다.  
인덱스를 수평적으로 탐색하는 이유는 조건절을 만족하는 데이터를 모두 찾기 위해서와 ROWID를 얻기 위해서다.  

<br>
<br>

## 2.1.5 결합 인덱스 구조와 탐색 
---
두개이상의 컬럼을 결합해서 인덱스를 만들 수 있다.  
책에 있는 그림과 설명을 봐야 이해가 수월한데.. 간단히 정리하자면 인덱스에서 남자 '이재희' 고객을 찾을때 인덱스를 [성별+이름]로 구성하던 [이름+성별]로 구성하든 읽는 인덱스 블록 개수가 똑같다는 사실이다. 인덱스를 어떻게 구성하든 블록 I/O 개수가 같으므로 성능도 똑같다. DBMS에서 사용하는 B*Tree 인덱스는 엑셀처럼 평면구조가 아니고 다단계 구조(루트,브랜치,리프)이기 때문이다.  
  
  
  
<br>
<br>
<br>
<br>
![img01]({{ site.baseurl }}/images/post/sqlTuning/book/bookCover.PNG)<br>
<br>
본 포스팅은 친절한 SQL 튜닝 온라인 스터디를 진행하면서 공부한 내용을 바탕으로 작성하였습니다.<br>
<br>
<br>
<br>