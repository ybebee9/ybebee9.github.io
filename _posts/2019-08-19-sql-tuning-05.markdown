---
layout: post
title:  "2.2 인덱스 기본 사용법"
date:   2019-08-19
categories: SQL튜닝
---  
## 2.1.1 인덱스를 사용한다는것
---
데이터 색인이 정렬되어있기 때문에 인덱스를 정상적으로 사용할 수 있는 것이다. 
예를 들어 '책상'이라는 단어를 찾을때 데이터가 가나다순으로 정렬되어있기 때문에 첫 글자를 수직적 탐색으로 쭉 스캔하다가 첫글자가 'ㅊ'으로 시작하는곳에서 '책상'을 찾고 그 이후에 글자인 'ㅋ','ㅌ','ㅍ','ㅎ'는 스캔 하지 않는다.  
<br>
색인이 정렬되어 있더라도 가공한 값이나 중간값(중간에 포함된 값)으로는 스캔 시작점을 찾을 수 없다.
만약 데이터중 '책상'을 포함하는 단어를 찾을 경우(ex.걸이식책상 등)에는 일정한 시작점을 찾을 수 없기 때문에 데이터 전체를 스캔해야한다. 
<br>
정리하면,  
Index Range Scan : 리프 블록 일부만 스캔  
Index Full Scan : 일부가 아닌 전체 스캔  
<br>
<br>
<br>
## 2.2.2 인덱스를 Range Scan 할 수 없는 이유
---
**"인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용(Range Scan)할 수 없다."**
<br>
인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는 인덱스 스캔 시작점을 찾을 수 없기 때문이다.  
Index Range Scan에서 'Range'는 범위를 의미하며 일정 범위를 스캔한다는 뜻이다.  
일정범위를 스캔하려면 '시작지점'과 '끝지점'이 있어야 한다. 그러나 '시작지점'과 '끝지점'을 명확히 알 수 없는 경우 Index Range Scan이 불가능하다.  
<br>
**But, Range Scan이 가능한 경우**  
1) UNION ALL 방식으로 작성하면 각 브랜치 별로 인덱스 스캔 시작점을 찾을 수 있어 Range Scan이 가능하다.  
2) OR 또는 IN 조건절은 옵티마이저의 쿼리변환 기능을 통해 Index Range Scan으로 처리되기도 한다.  
<br>
<br>
<br>
## 2.2.3 더 중요한 인덱스 사용 조건
---
조건절에서 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다..  
인덱스를 Range Scan 하려면 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있어야 한다.  
<br>
<br>
<br>
## 2.2.4 인덱스를 이용한 소트 연산 생략
---
예를 들어 [장비번호 + 변경일자 + 변경순번]순으로 구성한 테이블이 있다고 가정해보자. PK 인덱스에서 장비번호, 변경일자가 같은 레코드는 변경순번 순으로 정렬돼있다.이런 경우 SQL에 ORDER BY가 있어도 정렬 연산을 따로 수행하지 않는다. PK 인덱스를 스캔하면서 출력한 결과집합은 어차피 변경순번 순으로 정렬되기 때문이다.  
<br>
<br>
<br>
## 2.2.5 ORDER BY 절에서 컬럼 가공
---
ORDER BY 또는 SELECT-LIST에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 종종 있다.  
인덱스에는 가공하지 않은 상태로 값을 저장했는데, ORDER BY절에 가공한 값 기준으로 정렬을 요청하는 경우에도 그렇다.  
<br>
<br>
<br>
## 2.2.6 SELECT-LIST에서 컬럼 가공 
---
MIN값이나 MAX값을 구할 때 인덱스를 이용해 정렬 연산 없이 최소 또는 최댓값을 구할 수 있다.  
인덱스 리프 블록의 왼쪽(MIN) 또는 오른쪽(MAX)에서 레코드 하나(FIRST ROW)만 읽고 멈춘다.  
그러나 인덱스에는 변경순번이 문자열 기준으로 정렬되어있는데, 이를 숫자값으로 바꾼 값 기준으로 변경순번 정렬을 요구하면 정렬연산을 생략할 수 없다.  
```sql
SELECT NVL(MAX(TO_NUMBER(변경순번)),0)
FROM   상태변경이력
```
<br>
<br>
<br>
## 2.2.7 자동 형변환
---
예를들어 어떤 컬럼이 문자형인데 조건절 비교값을 숫자형으로 표현한 경우, 결과적으로 인덱스 컬럼이 가공됐기 대문에 인덱스를 Range Scan 할 수 없다. 
오라클에서 숫자형과 문자형이 만나면 숫자형이 Win! 즉, 숫자형 컬럼 기준으로 문자형 컬럼을 변환한다.  
연산자가 LIKE일때는 LIKE 자체가 문자열 비교 연산자이므로 이때는 문자형 기준으로 숫자형 컬럼이 변환된다.  
LIKE 조건으로 검색하면 자동 형변환이 발생해 인덱스 액세스 조건으로 사용되지 못하는 경우가 있기 때문에 주의해야한다.  
이외에도 자동형변환 때문에 성능과 애플리케이션 품질에 종종 문제가 생기기 때문에 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 정확히 형변환 해주어야 한다.
<br>
<br>
<br>
<br>
![img01]({{ site.baseurl }}/images/post/sqlTuning/book/bookCover.PNG)<br>
<br>
본 포스팅은 친절한 SQL 튜닝 온라인 스터디를 진행하면서 공부한 내용을 바탕으로 작성하였습니다.<br>
<br>
<br>
<br>