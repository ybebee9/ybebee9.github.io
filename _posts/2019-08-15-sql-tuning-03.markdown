---
layout: post
title:  "1.3 데이터 저장 구조 및 I/O 메커니즘"
date:   2019-08-15
categories: SQL튜닝
---  
## 1.3.1 SQL이 느린 이유
---
SQL이 느린 이유는 디스크 I/O 때문이다.
프로세스는 생명주기를 갖는다. 여러 프로세스가 하나의 CPU를 공유할 수 있지만, 특정 순간에는 하나의 프로세스만 CPU를 사용할 수 있다.
디스크에서 데이터를 읽어야 할 때 CPU를 OS에 반환하고 I/O가 완료되기를 기다리기 때문에 I/O가 많으면 성능이 느릴 수 밖에 없다. 
  
  
  
  
## 1.3.2 데이터베이스 저장 구조 
---
테이블 스페이스 : 세그먼트를 담는 컨테이너, 여러개의 데이터 파일로 구성된다.
세그먼트 : 테이블, 인덱스처럼 데이터 저장공간이 필요한 오브젝트
익스텐트 : 연속된 블록들의 집합. 공간을 확장하는 단위
블록(=페이지) : 데이터를 읽고 쓰는 단위
데이터 파일 : 디스크 상의 물리적인 OS파일
  
**DBA(Data Block Address)**
> 모든 데이터 블록은 디스크 상에서 몇 번 데이터파일의 몇 번째 블록인지를 나타내는 자신만의 고유 주소값을 갖는다.  
> 이 주소값을 'DBA(Data Block Address)'라고 한다.  
> 테이블을 스캔할 때는 테이블 세그먼트 헤더에 저장된 익스텐트 맵을 이용한다.
> 익스텐트 맵을 통해 각 인스텐트의 첫번째 블록 DBA를 알 수 있다. 
  
  
  
  
## 1.3.3 블록 단위 I/O
---
블록이 DBMS가 데이터를 읽고 쓰는 단위다.  
테이블뿐만 아니라 인덱스도 블록 단위로 데이터를 읽고 쓴다.
데이터 I/O 단위가 블록이므로 특정 레코드 하나를 읽고 싶어도 해당 블록을 통째로 읽는다.  

**오라클 데이터베이스의 블록 사이즈 확인법**
```sql
show parameter block_size
```

**V$PARAMETER 뷰를 직접 조회하는 방법**
```sql
select value from v$parameter where name = 'db_block_size';
```

  
  
  
  
## 1.3.4 시퀀셜 액세스 vs 랜덤 액세스
---
**시퀀셜(Sequential) 액세스** : 논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식. 테이블 블록 간에 논리적인 연결고리를 갖고 있지 않은 경우에는 읽어야 할 익스텐트 목록을 익스텐트 맵에서 얻고, 각 익스텐트의 첫 번째 블록 뒤에 연속해서 저장된 블록을 순서대로 읽으면, 그것이 곧 Full Table Scan이다. 

**랜덤(Random) 액세스** : 논리적, 물리적 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근(=touch)하는 방식.
  
  
  
  
  
## 1.3.5 논리적 I/O vs 물리적 I/O
---
모든 DBMS엔 데이터 캐싱 메커니즘이 필수다.  
DB 버퍼 캐시는 '데이터 캐시'라고 할 수 있으며, 디스크에서 어렵게 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적인 I/O Call을 줄이는 데 목적이 있다.  
서버 프로세스와 데이터 파일 사이에 버퍼캐시가 있으므로 데이터 블록을 읽을 땐 항상 버퍼캐시부터 탐색한다.  
버퍼캐시는 공유메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 득을 본다. 
    
**버퍼캐시 사이즈를 확인하는 법**
```sql
show sga
```
  
  
**논리적 I/O** : SQL문을 처리하는 과정에서 메모리 버퍼캐시에서 발생한 총 블록 I/O. 논리적 블록 I/O중 일부를 물리적 I/O로 하는 경우도 있음 
**물리적 I/O** : 디스크 버퍼캐시에서 블록을 찾지 못해 디스크에서 읽은 블록 I/O. 
  
디스크 I/O는 메모리 I/O에 비해 상당히 느리다.
  
  
**버퍼캐시 히트율(Buffer Cache Hit Ratio)**
> 버퍼캐시 효율을 측정하는데 가장 많이 사용해 온 지표
> BCHR = ( 캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수) x 100
>      = ((논리적 I/O - 물리적 I/O) / 논리적 I/O) x 100
>      = ( 1 - ( 물리적 I/O ) / ( 논리적 I/O ) ) x 100
> 
> BCHR이 SQL의 성능을 좌우하지만, BCHR이 높다고 해서 효율적인 SQL을 의미하지는 않는다.
    
**물리적  I/O가 성능을 결정하지만, 실제 SQL 성능을 향상하려면 물리적 I/O가 아닌 논리적 I/O를 줄여야 한다.**
**논리적 I/O를 줄임으로써 물리적 I/O를 줄이는 것이 곧 SQL튜닝이다.**
  
  
  

## 1.3.6 Singleblock I/O vs Multiblock I/O
---
**Singleblock I/O** : 한번에 한 블록씩 요청해서 메모리에 적재하는 방식. 소량 데이터를 읽을 때 효율적이다.  
**Multiblock I/O** : 한번에 여러 블록씩 요청해서 메모리에 적재하는 방식. 많은 데이터 블록을 읽을 때 효율적이다. 캐시에서 찾지 못한 특정 블록을 읽으려고 I/O Call 할 때 디스크 상에 그 블록과 '인접한' 블록들을 한꺼번에 읽어 캐시에 미리 적재하는 기능이다. 
  
  
  
  
  
## 1.3.7 Table Full Scan vs Index Range Scan
---
**Table Full Scan** : 테이블 전체를 스캔해서 읽는 방식. 테이블에 속한 블록 '전체'를 읽어서 사용자가 원하는 데이터를 찾는 방식. 시퀀셜 액세스와 Multiblock I/O 방식으로 디스크 블록을 읽는다. 많은 데이터를 읽을 때 유리하다.

**Index Range Scan** : 인덱스를 이용해서 읽는 방식. 인덱스에서 '일정량'을 스캔하면서 얻은 ROW ID로 테이블 레코드를 찾아가는 방식. 큰 테이블에서 소량 데이터를 검색할 때는 반드시 인덱스를 이용해야 함. 랜덤 액세스와 Singleblock I/O 방식으로 디스크 블록을 읽는다.
  
인덱스가 SQL의 성능을 떨어트리는 경우도 상당히 많다. Table Full Scan을 각 블록을 단 한번 읽는데, Index Range Scan은 읽었던 블록을 반복해서 읽는 비효율이 있다. 인덱스는 큰 테이블에서 아주 적은 일부 데이터를 빨리 찾기 위한 도구일 뿐, 모든 성능 문제를 인덱스로 해결하려고 해서는 안된다.
  
  
  
