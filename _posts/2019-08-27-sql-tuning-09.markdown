---
layout: post
title:  "3.3 인덱스 스캔 효율화"
date:   2019-08-27
categories: SQL튜닝
---  
## 3.3.1 인덱스 탐색
---
**수직적 탐색** : 스캔 시작점을 찾는 과정  
스캔 시작점과 끝점은 스캔량을 줄이는 역할을 함.  
조건절로 범위를 지정할 때 스캔 시작점과 끝점이 결정됨.  
조건절이 명확하지 않은 경우 스캔 시작점이나 끝점이 제 역할을 제대로 수행하지 못하는 경우도 있음.  
<br>
<br>
<br>
## 3.3.2 인덱스 스캔효율성
---
인덱스 선행 컬럼이 조건절에 없거나 '=' 조건이 아니면 인덱스 스캔 과정에 비효율이 발생한다.  
<br>
### 인덱스 스캔 효율성 측정
SQL 트레이스를 통해 알 수 있는데 cr이 읽은 블록 개수다.  
읽은 블록 개수(cr)와 스캔하여 얻은 레코드 수를 비교해보면 스캔 효율이 좋은지 나쁜지 알 수 있다.
읽은 블록 개수(cr)와 스캔하여 얻은 레코드 수가 차이가 적을수록 스캔 효율이 좋은것.  
<br>
<br>
<br>
## 3.3.3 액세스 조건과 필터 조건
---
인덱스 액세스 조건 : 인덱스 스캔 범위를 결정하는 조건절. 인덱스 수직적 탐색을 통해 스캔 시작점을 결정하는데 영향을 미치고, 인덱스 리프 블록을 스캔하다가 어디서 멈출지를 결정하는 데 영향을 미치는 조건절.  
인덱스 필터 조건 : 테이블로 액세스할지를 결정하는 조건절. 
테이블 필터 조건 : 테이블 액세스 단계에서 처리되는 조건절. 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정함.
<br>
<br>
<br>
## 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성
---
선행 컬럼이 모두 '=' 조건인 상태에서 첫번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여 있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다.  
선행 컬럼이 모두 '=' 조건인 상태에서 첫번째 나타나는 범위검색 조건이 인덱스 스캔 범위를 결정한다(=인덱스 액세스 조건). 나머지 인덱스 컬럼 조건은 모두 인덱스 필터 조건이다.  
<br>
<br>
<br>
## 3.3.5 인덱스 선행 컬럼이 등치(=)조건이 아닐 때 생기는 비효율
---
인덱스 스캔의 효율성은 인덱스 컬럼을 조건절에 모두 등치(=) 조건으로 사용할 때 가장 좋다.  
인덱스 선행 컬럼이 모두 '=' 조건일 때 필요한 범위만 스캔하고 멈출 수 있는것은, 조건을 만족하는 레코드가 모두 한데 모여있기 때문이다.  
<br>
<br>
<br>
## 3.3.6 BETWEEN을 IN-List로 전환
---
범위검색 컬럼이 맨 뒤로 가도록 인덱스를 구성 순서를 변경하면 좋겠지만 운영 시스템에서는 쉽지않다.  
이럴때 BETWEEN 조건을 IN-List로 바꿔주면 큰 효과를 얻는 경우가 있다.  
ex) where 인터넷매물 in ('1','2','3');  
IN-List 개수만큼 UNION ALL 브랜치가 생성되고 각 브랜치마다 모든 컬럼을 '='조건으로 검색하므로 선두컬럼에 BETWEEN을 사용할 때와 같은 비효율이 사라진다.
BETWEEN 조건을 IN-List로 전환할 때 주의사항은 책을 참고하자..  
<br>
<br>
<br>
## 3.3.7 Index Skip Scan 활용
---
BETWEEN 조건을 IN-List 조건으로 변환하면 도움이 되는 상황에서 굳이 조건절을 바꾸지 않고도 같은 효과를 내는 방법은 Index Skin Scan을 활용하는 것이다.  
Index Skip Scan이 IN-List보다 오히려 나은 경우도 있다.  
선두 컬럼이 BETWEEN이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 때, Index Skip Scan의 위력이 나타난다.  
<br>
<br>
<br>
## 3.3.8 IN 조건은 '=' 인가
---
IN 조건은 '='이 아니다. 따라서 인덱스를 어떻게 구성하느냐에 따라 성능도 달라질 수 있다.  
IN 조건이 '='이 되려면 IN-List Iterator 방식으로 풀려야만 한다. 그렇지 않으면 IN 조건은 필터조건이다.  
하지만 IN 조건을 '='조건으로 만들기 위해, 즉 액세스 조건으로 만들기 위해 IN-List Iterator방식으로 푸는 것이 항상 효과적인것은 아니다.  
데이터가 아주 많은 경우에는 IN 조건을 액세스 조건으로 사용하는것이 낫고, 그렇지 않은 경우에는 필터 방식으로 처리되는게 낫다.  
<br>
<br>
<br>
## 3.3.9 BETWEEN과 LIKE 스캔 범위 비교
---
LIKE와 BETWEEN은 둘 다 범위검색 조건이다. LIKE보다 BETWEEN을 사용하는것이 낫다.  
자세한 설명은 책 참고~  
<br>
<br>
<br>
## 3.3.10 범위검색 조건을 남용할 때 생기는 비효율
---
인덱스 컬럼에 범위조건 검색을 남용하면 인덱스 스캔 비효율이 생긴다.  
인덱스 스캔 비효율이 성능에 미치는 영향이 적을 수도 있지만, 대량의 테이블을 넓은 범위로 검색할 때는 그 영향이 매우 클 수도 있다.  
따라서 SQL을 작성할 때 데이터 분포에 따라 인덱스 컬럼에 대한 비교 연산자를 신중하게 선택해야한다.  
<br>
<br>
<br>
## 3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교
---
### OR조건
인덱스 선두 컬럼에 대한 옵션 조건에 OR 조건을 사용해선 안된다.  
인덱스에 포함되지 않은 컬럼에 대한 옵션조건은 테이블에서 필터링할 수 밖에 없으므로 OR조건을 사용해도 무방.  
**OR 조건을 활용한 옵션 조건 처리**
> 인덱스 액세스 조건으로 사용 불가  
> 인덱스 필터 조건으로도 사용 불가  
> 테이블 필터 조건으로만 사용 가능  

<br>
참고로 OR-Expansion을 통해 인덱스 사용이 가능하도록 OR조건 형태를 만들 수 있음. 그 방법은 책 설명 참고.  
<br>
### LIKE/BETWEEN 조건 활용
필수 조건 컬럼을 인덱스 선두에 두고 액세스 조건으로 사용하면, LIKE/BETWEEN이 인덱스 필터 조건이어도 충분히 좋은 성능을 낼 수 있다.  
**LIKE/BETWEEN 패턴을 사용하고자 할때 아래 네가지 경우에 속하는지 반드시 점검 필요**
> 인덱스 선두 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 연산자로 처리하는것은 금물.  
> NULL 허용 컬럼에 대한 옵션 조건을 LIKE/BETWEEN 연산자로 처리하는것도 금물.  
> 숫자형이면서 인덱스 액세스 조건으로도 사용 가능한 컬럼에 대한 옵션 조건 처리는 LIKE 방식을 사용해서는 안됨.  
> LIKE를 옵션 조건에 사용할 때는 컬럼 값 길이가 고정적이어야 한다.
<br>
### UNION ALL 활용
UNION ALL 방식은 옵션 조건 컬럼도 인덱스 액세스 조건으로 사용한다는 사실이 매우 중요.  
<br>
### NVL/DECODE 함수 활용 
UNION ALL보다 단순하면서도 UNION ALL과 같은 성능을 낸다.  
단점은 NULL 허용 컬럼에 사용할 수 없다. 조건절 변수에 NULL을 입력하면 값이 NULL인 레코드가 결과집합에서 누락되기 때문이다.  
자세한 내용은 책 참고.  
<br>
<br>
<br>
## 3.3.12 함수호출부하 해소를 위한 인덱스 구성
---
### PL/SQL 함수의 성능적 특성
**PL/SQL 사용자 정의 함수가 느린 이유 3가지**
> 가상머신(VM)상에서 실행되는 인터프리터 언어  
> 호출시마다 컨텍스트 스위칭 발생  
> 내장 SQL에 대한 Recursive Call 발생  
대개 PL/SQL 함수에는 SQL이 내장되어있으므로 일반적으로 인터프리팅, 컨텍스트 스위칭보다 Recursive Call부하가 가장 크다.  
PL/SQL 함수를 쓰지않고 조인문으로 처리하면 성능이 훨씬 좋은 경우도 있다. 함수가 무조건 좋은것은 아니다.  
<br>
<br>
<br>
## 3.3.7 Index Skip Scan 활용
---

<br>
<br>
<br>
<br>
![img01]({{ site.baseurl }}/images/post/sqlTuning/book/bookCover.PNG)<br>
<br>
본 포스팅은 친절한 SQL 튜닝 온라인 스터디를 진행하면서 공부한 내용을 바탕으로 작성하였습니다.<br>
<br>
<br>
<br>