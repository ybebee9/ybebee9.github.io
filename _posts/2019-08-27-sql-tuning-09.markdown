---
layout: post
title:  "3.3 인덱스 스캔 효율화"
date:   2019-08-27
categories: SQL튜닝
---  
## 3.3.1 인덱스 탐색
---
**수직적 탐색** : 스캔 시작점을 찾는 과정  
스캔 시작점과 끝점은 스캔량을 줄이는 역할을 함.  
조건절로 범위를 지정할 때 스캔 시작점과 끝점이 결정됨.  
조건절이 명확하지 않은 경우 스캔 시작점이나 끝점이 제 역할을 제대로 수행하지 못하는 경우도 있음.  
<br>
<br>
<br>
## 3.3.2 인덱스 스캔효율성
---
인덱스 선행 컬럼이 조건절에 없거나 '=' 조건이 아니면 인덱스 스캔 과정에 비효율이 발생한다.  
<br>
### 인덱스 스캔 효율성 측정
SQL 트레이스를 통해 알 수 있는데 cr이 읽은 블록 개수다.  
읽은 블록 개수(cr)와 스캔하여 얻은 레코드 수를 비교해보면 스캔 효율이 좋은지 나쁜지 알 수 있다.
읽은 블록 개수(cr)와 스캔하여 얻은 레코드 수가 차이가 적을수록 스캔 효율이 좋은것.  
<br>
<br>
<br>
## 3.3.3 액세스 조건과 필터 조건
---
인덱스 액세스 조건 : 인덱스 스캔 범위를 결정하는 조건절. 인덱스 수직적 탐색을 통해 스캔 시작점을 결정하는데 영향을 미치고, 인덱스 리프 블록을 스캔하다가 어디서 멈출지를 결정하는 데 영향을 미치는 조건절.  
인덱스 필터 조건 : 테이블로 액세스할지를 결정하는 조건절. 
테이블 필터 조건 : 테이블 액세스 단계에서 처리되는 조건절. 쿼리 수행 다음 단계로 전달하거나 최종 결과집합에 포함할지를 결정함.
<br>
<br>
<br>
## 3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성
---
선행 컬럼이 모두 '=' 조건인 상태에서 첫번째 나타나는 범위검색 조건까지만 만족하는 인덱스 레코드는 모두 연속해서 모여 있지만, 그 이하 조건까지 만족하는 레코드는 비교 연산자 종류에 상관없이 흩어진다.  
선행 컬럼이 모두 '=' 조건인 상태에서 첫번째 나타나는 범위검색 조건이 인덱스 스캔 범위를 결정한다(=인덱스 액세스 조건). 나머지 인덱스 컬럼 조건은 모두 인덱스 필터 조건이다.  
<br>
<br>
<br>
## 3.3.5 인덱스 선행 컬럼이 등치(=)조건이 아닐 때 생기는 비효율
---
인덱스 스캔의 효율성은 인덱스 컬럼을 조건절에 모두 등치(=) 조건으로 사용할 때 가장 좋다.  
인덱스 선행 컬럼이 모두 '=' 조건일 때 필요한 범위만 스캔하고 멈출 수 있는것은, 조건을 만족하는 레코드가 모두 한데 모여있기 때문이다.  
<br>
<br>
<br>
## 3.3.6 BETWEEN을 IN-List로 전환
---
범위검색 컬럼이 맨 뒤로 가도록 인덱스를 구성 순서를 변경하면 좋겠지만 운영 시스템에서는 쉽지않다.  
이럴때 BETWEEN 조건을 IN-List로 바꿔주면 큰 효과를 얻는 경우가 있다.  
ex) where 인터넷매물 in ('1','2','3');  
IN-List 개수만큼 UNION ALL 브랜치가 생성되고 각 브랜치마다 모든 컬럼을 '='조건으로 검색하므로 선두컬럼에 BETWEEN을 사용할 때와 같은 비효율이 사라진다.
BETWEEN 조건을 IN-List로 전환할 때 주의사항은 책을 참고하자..  
<br>
<br>
<br>
## 3.3.7 Index Skip Scan 활용
---
BETWEEN 조건을 IN-List 조건으로 변환하면 도움이 되는 상황에서 굳이 조건절을 바꾸지 않고도 같은 효과를 내는 방법은 Index Skin Scan을 활용하는 것이다.  
Index Skip Scan이 IN-List보다 오히려 나은 경우도 있다.  
선두 컬럼이 BETWEEN이어서 나머지 검색 조건을 만족하는 데이터들이 서로 멀리 떨어져 있을 때, Index Skip Scan의 위력이 나타난다.  
<br>
<br>
<br>
<br>
![img01]({{ site.baseurl }}/images/post/sqlTuning/book/bookCover.PNG)<br>
<br>
본 포스팅은 친절한 SQL 튜닝 온라인 스터디를 진행하면서 공부한 내용을 바탕으로 작성하였습니다.<br>
<br>
<br>
<br>